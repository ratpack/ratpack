# Testing Ratpack Applications

Ratpack applications should be easy to test. In this chapter, you will learn about the many convenience methods and utilities available as part of Ratpack's testing support.

## Spock Integration

Spock is a testing and specification framework for Java and Groovy applications. If you are unfamiliar with Spock, please read refer to the [Spock Framework Reference](https://spock-framework.readthedocs.org/en/latest/) for more information.

Support for running Spock tests is provided via the ratpack-groovy plugin for Gradle, this is included in the template generated by Lazybones.

To include the plugin manually, you should copy the corresponding entries from the build.gradle file in the sample [gradle-groovy-app]( https://github.com/ratpack/example-ratpack-gradle-groovy-app/blob/master/build.gradle)

Once you have included the ratpack-groovy plugin, you can run your Spock tests via:

```
./gradlew test
```

## Unit Testing Ratpack Handlers with invoke()

The invoke() mechanism within Ratpack allows you to unit test [`Handlers`](api/org/ratpackframework/handling/Handler.html) without starting up a Ratpack server. 

Let's assume we have a Handler that looks like the following:

```
class MyHandler implements Handler {
  @Override
  void handle(Context context) {
    context.with {
      response.headers.set("set-header", "set")
      response.send request.headers.get("test-header") + ":" + request.uri
    }
  }
}
```

If we ran this Handler, we would expect:

* Headers: 'set-header' with the value of set.
* Body: The value of the 'test-header' header. Followed by a ':'. Followed by the requesting path.

The specification for this handler will look like this:

```
package org.ratpackframework.test.handling

import spock.lang.Specification
import static org.ratpackframework.groovy.test.handling.InvocationBuilder.invoke //1

class MyHandlerSpec extends Specification {

  def "should set a header and return the uri path in the body"() {
    when: "call invoke on MyHandler"
    def invocation = invoke(new MyHandler()) { // 2
      requestHeaders.set("Test-Header", "foo")
      uri = "/bar"
    }

    then: "expect the correct headers and body text to be returned"
    invocation.getHeaders().get("set-header") == "set" //3
    invocation.getBodyText() == "foo:/bar"
  }
}
```

1. First, we import the invoke method from the [`InvocationBuilder`](api/org/ratpackframework/groovy/test/handling/InvocationBuilder.html) so that we can unit test our Handler

2. The invoke method in our when block takes in an instance of the handler under test, followed by the invocation being built, which is a DSL. 

3. Invoke returns a [`Invocation`](api/org/ratpackframework/groovy/test/handling/InvocationBuilder.html). We can query the invocation to make sure our implementation is correct.

### Building Invocations

In the closure passed to invoke(), you can set the following:

* __requestHeaders__ - this is a [`Headers`](api/org/ratpackframework/http/Headers.html) object. You can add headers via requestHeaders.set(name, value).
* __method__ - Either one of the following Strings: "GET", "POST", "HEAD", "PUT" or "DELETE". Defaults to "GET". 
* __uri__ - this is a String like "/bar?myHorse=big"
* __requestBody__ - this is a Netty ByteBuf that represents the content in the request body.
* __timeout__ - if the invocation exceeds this time, it will throw a InvocationTimeoutException.

### Checking Invocation Results

Once invoked, an [`Invocation`](api/org/ratpackframework/groovy/test/handling/InvocationBuilder.html) can be checked for the following:

* __isSentResponse()__ - returns false when either next() or response.sendFile() is used. 
* __isCalledNext()__ - For asynchronous handlers, set to true when next() is called in the handler.
* __getBodyText()__ - the response body as a String
* __getBodyBytes()__ - the response body in bytes
* __getException()__ - if the handler throws an exception, this will map to it.
* __getHeaders()__ - response headers
* __getSentFile()__ - When a handler uses response.sendFile, this method will return the file being sent. 
* __getStatus()__ - http status of the response

### Testing Template Rendering

We are also able to unit test handlers that render a template. 

The following handler renders out into a groovy template called index.html.

```
class RenderingHandler implements Handler {
  @Override
  void handle(Context context) {
    context.render Template.groovyTemplate("index.html", a: "a")
  }
}
```

The corresponding specification looks as follows:

```
def "can unit test a handler that renders a template"() {
  when:
  def invocation = invoke(new RenderingHandler()) {}
  Template template = invocation.rendered(Template)

  then:
  template.id == "index.html"
  template.model == [a: "a"]
}
```

The Invocation interface contains a method called rendered. This will return a [`Template`](/api/org/ratpackframework/groovy/Template.html) that has been processed by the rendering engine. In your specifications, you can check that the correct id, model or type is being returned.

### Additional Resources

If you want a full example of unit testing in Ratpack Handlers, Rob Fletcher's Mid Century Ipsum project contains of a fully implemented [Handler](https://github.com/robfletcher/midcentury-ipsum/blob/master/src/main/groovy/com/energizedwork/midcenturyipsum/IpsumHandler.groovy) and associated [test](https://github.com/robfletcher/midcentury-ipsum/blob/master/src/test/groovy/com/energizedwork/midcenturyipsum/IpsumHandlerSpec.groovy).
