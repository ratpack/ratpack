# Testing Ratpack applications

Ratpack applications should be easy to test. In this chapter, you will learn about the many convenience methods and utilities available as part of Ratpack's unit testing support.

## Spock integration

Spock is a testing and specification framework for Java and Groovy applications. If you are unfamiliar with Spock, please refer to the [Spock Framework Reference](https://spock-framework.readthedocs.org/en/latest/) for more information.

Support for running Spock tests is provided via the *ratpack-groovy* plugin for Gradle, this is included in the template generated by Lazybones.

To include the plugin manually, you should copy the corresponding entries from the *build.gradle* file in the sample [gradle-groovy-app]( https://github.com/ratpack/example-ratpack-gradle-groovy-app/blob/master/build.gradle)

Once you have included the *ratpack-groovy* plugin, you can run your Spock tests via:

```language-bash
./gradlew test
```

## Unit testing Ratpack handlers

The [`InvocationBuilder`](api/ratpack/test/handling/InvocationBuilder.html) and [`Invocation`](api/ratpack/test/handling/Invocation.html) classes in the Ratpack test API allow you to unit test your [`Handler`](api/ratpack/handling/Handler.html) implementations without starting up a Ratpack server.

Let's assume we have a `Handler` implementation that looks like this:

```language-groovy
class MyHandler implements Handler {
  @Override
  void handle(Context context) {
    context.with {
      response.headers.set("set-header", "set")
      response.send request.headers.get("test-header") + ":" + request.uri
    }
  }
}
```

If we run this handler, we would expect:

* Headers: *"set-header"* with the value of *"set"*.
* Body: The value of the *test-header* header followed by a *":"* and the request URI.

The specification for this handler will look like this:

```language-groovy
package ratpack.test.handling

import spock.lang.Specification

class MyHandlerSpec extends Specification {

  def "should set a header and return the uri path in the body"() {
    given: "a handler context is established"
    def builder = new InvocationBuilder() // 1
    builder.header "Test-Header", "foo"
    builder.uri "/bar"

    when: "call invoke on MyHandler"
    def invocation = builder.invoke(new MyHandler()) // 2

    then: "expect the correct headers and body text to be returned"
    invocation.getHeaders().get("set-header") == "set" // 3
    invocation.getBodyText() == "foo:/bar"
  }
}
```

1. First, we construct a new `InvocationBuilder` and call methods on it to establish the context the handler will run in.
2. The invoke method in our when block takes in an instance of the handler under test.
3. `InvocationHandler.invoke` returns an `Invocation` that we can query to make sure our handler implementation behaved as expected.

### Establishing the handler context

You can use the following methods on `InvocationBuilder` to establish the handler context:

* `header(String, String)` - adds a request header.
* `method(String)` - sets the HTTP request method.
* `uri(String)` - sets the request URI using a string such as "/bar?myHorse=big"
* `body(byte[], String)` - sets the request body using a byte array and a MIME type.
* `body(String, String)` - sets the request body using a String and a MIME type.
* `responseHeader(String, String)` - adds a response header. This is useful for testing handlers that are used downstream of other handlers.
* `responseBody(byte[], String)` - sets the request body using a byte array and a MIME type. This is useful for testing handlers that are used downstream of other handlers.
* `responseBody(String, String)` - sets the request body using a String and a MIME type. This is useful for testing handlers that are used downstream of other handlers.
* `timeout(int)` - if the handler does not respond within this many seconds the test will throw InvocationTimeoutException.

All the methods return the `InvocationBuilder` instance so you can use them in a *fluent* style if you prefer. For example:

```language-groovy
new InvocationBuilder()
   .header("Test-Header", "foo")
   .uri("/bar")
   .invoke(new MyHandler())
```

### Building the handler context inline

For simpler tests you can use an alternate syntax for handler tests. `InvocationHandler` has a static form of the `invoke` method that takes a closure as well as the handler. The closure is used to configure the handler context using the same methods as above.

The test above could be re-written as:

```language-groovy
package ratpack.test.handling

import spock.lang.Specification
import static ratpack.groovy.test.handling.InvocationBuilder.invoke // 1

class MyHandlerSpec extends Specification {

  def "should set a header and return the uri path in the body"() {
    when: "call invoke on MyHandler"
    def invocation = invoke(new MyHandler()) { // 2
      header "Test-Header", "foo"
      uri "/bar"
    }

    then: "expect the correct headers and body text to be returned"
    invocation.getHeaders().get("set-header") == "set" // 3
    invocation.getBodyText() == "foo:/bar"
  }
}
```

1. First, we import the static form of the `invoke` method from the [`InvocationBuilder`](api/ratpack/groovy/test/handling/InvocationBuilder.html).
2. The invoke method in our when block takes in an instance of the handler under test, followed by a closure used for building the handler context. The methods available in the closure are identical to those available directly on `InvocationBuilder`.
3. The assertions are made in exactly the same way.

### Checking handler results

The various forms of `InvocationHandler.invoke` all return an `Invocation` that can be checked using the following methods:

* `isSentResponse()` - returns *true* if the handler sent a response directly or *false* if it called `next()` or `response.sendFile()`.
* `isCalledNext()` - for asynchronous handlers, set to `true` if the handler called `next()`.
* `getBodyText()` - the response body as a string.
* `getBodyBytes()` - the response body as a byte array.
* `getException()` - any exception thrown by the handler.
* `getHeaders()` - the response headers.
* `getSentFile()` - if the handler called `response.sendFile()` this method will return the file.
* `getStatus()` - the HTTP status of the response.

### Testing template rendering

It is also possible to unit test handlers that render a template.

The following handler renders out into a Groovy template called *index.html*.

```language-groovy
class RenderingHandler implements Handler {
  @Override
  void handle(Context context) {
    context.render Template.groovyTemplate("index.html", a: "a")
  }
}
```

The corresponding specification looks as follows:

```language-groovy
def "can unit test a handler that renders a template"() {
  given:
  def builder = new InvocationBuilder()

  when:
  def invocation = builder.invoke(new RenderingHandler())
  Template template = invocation.rendered(Template)

  then:
  template.id == "index.html"
  template.model == [a: "a"]
}
```

The Invocation interface contains a method `rendered(Class)`. This will return the object the handler rendered. In our example this is a [`Template`](/api/ratpack/groovy/Template.html) and we then check that the correct id, model and type were used.

### Additional Resources

If you want a full example of unit testing in Ratpack handlers, Rob Fletcher's *Mid-Century Ipsum* project contains [a handler implementation](https://github.com/robfletcher/midcentury-ipsum/blob/master/src/main/groovy/com/energizedwork/midcenturyipsum/IpsumHandler.groovy) and associated [unit test](https://github.com/robfletcher/midcentury-ipsum/blob/master/src/test/groovy/com/energizedwork/midcenturyipsum/IpsumHandlerSpec.groovy).
